从零开始实现<原神>服务器系列。。

## day1 基础模块的搭建

主要是完成玩家首页的一些信息展示。

玩家的基础模块信息，上线之后是要发给玩家的。

玩家信息模块，对应的应该是数据库中的某张表，玩家登录之后，从表里取出数据，发给客户端。

uid就不说了，生成之后就是不会改变的，其他信息，玩家名字、签名之类的都是可以更改的。

## day2 头像设置

项目中的接口一般分为两类：

1. 对外接口：由客户端触发，例如设置头像这种，需要外部可见；本项目中的此类接口规定使用`Recv`开头表示。
2. 内部接口：由服务器自身逻辑触发，例如玩家等级的提升，一定是不能暴露给客户端的，否则客户端被破解，玩家想设置几级就设置几级了。这部分接口是提供给服务器内部的逻辑调用的。

今天的代码可以看到，从基础模块的一个Icon字段就能够发展出一个Icon模块，后面也是同样的，每个基础模块的字段基本都能延伸出一个子模块，像一张大网一样不断的扩张与完善。

刚入职的时候，其实也就是写这些模块之间的互相调用，不牵扯算法啊之类的开发任务。

## day3 架构微调与名片设置

前面说到，项目中的接口包含**对外接口**。这部分接口其实适合放在player模块中，由`*player`模块统一处理。

这样做的好处是，我们要增加接口，那就去相应的模块下面写代码，调用的时候把`*player`指针传过去就行。

举个例子，增加设置头像接口，那就去`mod_player`模块下写一个处理设置头像逻辑的接口，然后在player模块中调用这个接口，并**传入`*player`指针，方便子模块调用其他子模块**：

```golang
func (p *Player) RecvSetIcon(iconId int) {
	...
	// 有相应的icon，才进行设置
	p.ModPlayer.setIcon(iconId, p)
}
```

如此，客户端直接跟Player玩家主体打交道，Player收到消息之后再去调用其他模块来完成功能，由于调用其他模块的时候传入了player指针，其他模块也可以相互之间彼此调用。

还以上面的栗子说明，客户端要设置头像，那么就到了player的设置头像接口：
```golang
// RecvSetIcon 设置头像
func (p *Player) RecvSetIcon(iconId int) {
	...
	p.ModPlayer.setIcon(iconId, p)
}
```

在接口内部，player调用ModPlayer基础模块来设置头像：

```golang
func (self *ModPlayer) setIcon(iconId int, player *Player) bool {

	if !player.ModIcon.isHasIcon(iconId) {
		fmt.Printf("can not find %d !", iconId)
		return false
	}
	player.ModPlayer.Icon = iconId
	fmt.Println("current icon:", iconId)
	return true
}
```

在基础模块设置头像逻辑的内部，基础模块又通过player指针调用了头像模块的<检查头像是否存在接口>，最终实现了整个头像的设置过程。

这样做还有个好处就是，想要调试的时候，第一个断点肯定打在这个地方，首先确保收到的数据是想要的数据，之后再去模块内部进行检查。

至此，架构微调就完成了：

1. player模块是最上层的模块，用来直接跟客户端打交道，接收客户端消息；
2. 基础模块mod_player内部的接口主体，都是mod_player.

另外说明一下，对比今天和昨天的名片和头像系统，说一下策划选择的问题。

原神的头像包，只展示所拥有的角色集合，而名片包会展示所有的名片，分为解锁和未解锁两部分。

对我们服务器开发来说，功能和逻辑都是一样的，理论上就是玩家登录之后，拿到数据库里面的数据，回给客户端就可以了。

区别在于客户端，是只根据服务器数据展示所有的数据，还是读全量配置，与服务器数据做交集，分为解锁和未解锁两部分；这个只是策划案的选择问题，没有什么好与不好。

## day4 名字和签名系统-初遇公共模块

名字和签名系统这类设计字符串的验证主要有以下几个方面：

1. 长度限制，比如名字不能超过6个字，这个一般交给客户端来做就行了，比如名字显示不全，一般玩家自己也会改掉的；

2. 特殊字符，这个后台也可以处理，比如将名字转换为字节流[]byte，然后循环判断名字里面是不是有斜杠`\`之类的字符。不过现在一般不做特殊字符校验了，因为数据库现在对这些字符的支持比较全面了，另外就是如果要做海外版的，他们的名字是包含很多奇怪字符的，比如小撇`'`之类的，所以干脆不处理，除非数据库报错；

3. 违禁词屏蔽。最直观的感觉肯定是使用正则表达式，但可能会很复杂，并且效果不好，比如加了一个生僻的偏旁，或者组合了一个那种人脑一看就知道是什么的字，防不胜防，也会影响服务器性能。

   现在主流的做法一般有两种：

   - 调一个三方接口，比如阿里的接口，丢给他们做字符串是否合法的校验，但这种方式也是存在风险的，作者给了一个现实的栗子，b站曾经做了一个<爆裂魔女>的游戏，玩家创建角色的时候，不管输入什么角色名，都显示非法字符，猜测可能是丢给三方接口去做校验了，这样一旦三方接口出现问题，所有的玩家都进不去游戏，对游戏本身是一个很大的伤害。
   - 更合理的做法当然还是交由自己的服务本身处理：初始化一个违禁词库的配置，定期主动或者被动去更新这个词库。这里就牵扯到项目的第一个公共管理模块了。

前面说过，对于服务器来说，每个玩家都是单开一个独立线程来处理消息的，但违禁词库这种东西肯定是一个公共的模块。

项目中的公共模块统一以`mgr`开头，代表他是一个**管理类**。

违禁词模块的核心功能其实就一个：验证某个字符串是否合法。

另外，玩家线程是客户端连接之后被动创建的，基础违禁词库的创建肯定是要服务器主动去创建的。

这里就用到了设计模式中的单例模式，要确保任何时候都可以拿到违禁词模块单例，并且这个单例是有值的。好处是在任何时候都能调用唯一的东西，以节约内存，也方便管理。

插句题外话，总体来说，改名和签名的违禁词，其实不太能完美的解决那些有意作恶的问题，最好的结果就是直接把号封掉。米哈游现在也是这样处理的。

虽然技术上很难做到完美，但是态度一定要有，玩家也很看重，对于树立正面形象、传递正能量也有积极作用。

## day5 main函数主线程设计

最开始这个项目的设计，线程模型是这样的：

1. 公共管理类，每个类对应一个线程，这部分线程数就是公共管理模块*1；
2. 玩家线程，玩家*1

例如共有200个玩家，10个公共模块，那么总线程数就是210.

golang可以这样写，是因为golang的协程十分轻量级，一个就几k，能够非常轻易的拉起大量协程。

这在其他语言是不可想象的，例如c++，他要调用内核级线程来实现，每个内核级线程都是10m起，那一个4g的内存最多只能支撑起400个玩家，这显然不现实。所以它的做法是采取队列的形式，接受数据，再排队交给内核级线程去处理。

编程是一门艺术，艺术来源于生活，所以线程模型往往能在现实生活中找到对应的栗子。比如去银行办理业务。

先说c++的实现。一开始，银行共有8个员工，7个业务员，负责在7个窗口办理业务，1个管理人员，用来协调业务处理。对应的游戏服务器就是7个玩家线程，1个管理线程，共8线程处理器。这样做是有很大隐患的，首先就是7个业务员的等待队列可能会分配不均，导致有些线程比较空闲，有些比较繁忙，另外就是多人开发，所有的管理模块挤在一个线程中相互调用，维护成本增加。而且C++有顺序要求，先调哪个模块后调哪个模块，调试起来比较简单，但后期修改维护成本就很高。

这个时候叫号机出现了，它的作用就是把所有的玩家归为一个队列，叫到号的根据实际情况分配到不同的业务窗口，这样就避免了某些窗口繁忙、某些窗口空闲的情况，其次就是还可以实现vip插队功能，这样就有点协程调度的意思在里面了。

而golang的做法是不分玩家线程和管理线程，把两种线程打乱分在一起，然后实现了一个协助者P，数量对应内核级线程，由P来协助调度goroutine，充分利用多核优势，哪个内核线程空了就安排上goroutine去执行。这样一来，管理模块也可以每个都单独起一个协程，而不必跟其他同事的管理模块混在一起。并且golang把调用解耦了，没有强制的顺序要求。

## day6 定时器和违禁词库的启用

违禁词库由两部分组成：

1. 服务器启动的时候能够加载基础的配置；
2. 定期扩展词库内容。

定期扩展词库的内容可以用一个定时任务来完成。定时任务要跑在一个单独的协程中，避免阻塞主线程。另外，主线程要做的最后一件事情一定是一个死循环，来监听客户端的消息并进行处理。

## day7 配置的加入与违禁词库的生成

main函数里面要做的第一件事，往往是导入配置。

一般配置表，例如excel都是策划来维护的。策划维护好表格之后，我们要做的就是利用导表工具，把excel转换成服务器更好利用的格式，比如csv(更像一个数组)，或者json(更像一个map)。csv和json也是可以互相转化的，关键就是在服务器的内部业务怎么方便去用。

## day8 增加人物经验和等级换算

前面说过，增加任务经验一定是个内置的接口，不可能由客户端来调说我要增加经验。一定是玩家完成了某些任务之后，由服务器内部来触发的。

所以增加经验的接口一定不能放在player模块（玩家的消息收发机制）中对外提供。

任务等级的excel文件已经由策划配置好，分别有等级升级需要的经验值，以及世界等级升级需要完成的任务编号。

## day9 任务模块和突破任务的判断

本节课涉及到了map的使用，但map是比较敏感的，它读写速度很快，但是多线程下并发读写会有问题，需要加锁。

任务的完成也是一个内置接口。可能本能反应以为它是跟客户端打交道的，客户端说我任务完成了就完成了，这是不可能的。

客户端在进入副本的时候，任务状态改为了doing，它可以在本地通过修改客户端的方式操作副本，比如一刀把怪秒了，这个操作是可以的，因为服务器验不到。

但是一定不允许你在副本里随便生成莫名其妙的怪，然后再打掉来刷经验。

好比副本里原来有10个怪，然后客户端打怪，通过编号告诉服务器打掉了哪个怪，或者最后全部打完之后进行地图的结算，绝不可能打掉一个地图中不存在的怪，或者一个怪打两次。这就是服务器的功能。



